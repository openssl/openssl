##
## Makefile for OpenSSL
##
## {- join("\n## ", @autowarntext) -}
{-
     our $objext = $target{obj_extension} || ".o";
     our $depext = $target{dep_extension} || ".d";
     our $exeext = $target{exe_extension} || "";
     our $libext = $target{lib_extension} || ".a";
     our $shlibext = $target{shared_extension} || ".so";
     our $shlibextsimple = $target{shared_extension_simple} || ".so";
     our $shlibextimport = $target{shared_import_extension} || "";
     our $dsoext = $target{dso_extension} || ".so";

     sub windowsdll { $config{target} =~ /^(?:Cygwin|mingw)/ }

     # shlib and shlib_simple both take a static library name and figure
     # out what the shlib name should be.
     #
     # When OpenSSL is configured "no-shared", these functions will just
     # return empty lists, making them suitable to join().
     #
     # With Windows DLL producers, shlib($libname) will return the shared
     # library name (which usually is different from the static library
     # name) with the default shared extension appended to it, while
     # shlib_simple($libname) will return the static library name with
     # the shared extension followed by ".a" appended to it.  The former
     # result is used as the runtime shared library while the latter is
     # used as the DLL import library.
     #
     # On all Unix systems, shlib($libname) will return the library name
     # with the default shared extension, while shlib_simple($libname)
     # will return the name from shlib($libname) with any SO version number
     # removed.  On some systems, they may therefore return the exact same
     # string.
     sub shlib {
         return () if $disabled{shared};
         my $lib = shift;
         return $unified_info{sharednames}->{$lib} . $shlibext;
     }
     sub shlib_simple {
         return () if $disabled{shared};

         my $lib = shift;
         if (windowsdll()) {
             return $lib . $shlibextimport;
         }
         return $lib .  $shlibextsimple;
     }

     # dso is a complement to shlib / shlib_simple that returns the
     # given libname with the simple shared extension (possible SO version
     # removed).  This differs from shlib_simple() by being unconditional.
     sub dso {
         my $engine = shift;

         return $engine . $dsoext;
     }
     '';
-}
PLATFORM={- $config{target} -}
OPTIONS={- $config{options} -}
CONFIGURE_ARGS=({- join(", ",quotify_l(@{$config{perlargv}})) -})
SRCDIR={- $config{sourcedir} -}
BLDDIR={- $config{builddir} -}

VERSION={- $config{version} -}
MAJOR={- $config{major} -}
MINOR={- $config{minor} -}
SHLIB_VERSION_NUMBER={- $config{shlib_version_number} -}
SHLIB_VERSION_HISTORY={- $config{shlib_version_history} -}
SHLIB_MAJOR={- $config{shlib_major} -}
SHLIB_MINOR={- $config{shlib_minor} -}
SHLIB_TARGET={- $target{shared_target} -}

LIBS={- join(" ", map { $_.$libext } @{$unified_info{libraries}}) -}
SHLIBS={- join(" ", map { shlib($_) } @{$unified_info{libraries}}) -}
ENGINES={- join(" ", map { dso($_) } @{$unified_info{engines}}) -}
PROGRAMS={- join(" ", map { $_.$exeext } grep { !m|^test/| } @{$unified_info{programs}}) -}
TESTPROGS={- join(" ", map { $_.$exeext } grep { m|^test/| } @{$unified_info{programs}}) -}
SCRIPTS={- join(" ", @{$unified_info{scripts}}) -}
{- output_off() if $disabled{makedepend}; "" -}
DEPS={- join(" ", map { (my $x = $_) =~ s|\.o$|$depext|; $x; }
                  grep { $unified_info{sources}->{$_}->[0] =~ /\.c$/ }
                  keys %{$unified_info{sources}}); -}
{- output_on() if $disabled{makedepend}; "" -}
GENERATED={- join(" ", map { (my $x = $_) =~ s|\.S$|\.s|; $x } keys %{$unified_info{generate}}) -}

BIN_SCRIPTS=$(BLDDIR)/tools/c_rehash
MISC_SCRIPTS=$(SRCDIR)/tools/c_hash $(SRCDIR)/tools/c_info \
	     $(SRCDIR)/tools/c_issuer $(SRCDIR)/tools/c_name \
	     $(BLDDIR)/apps/CA.pl $(SRCDIR)/apps/tsget

SHLIB_INFO={- join(" ", map { "\"".shlib($_).";".shlib_simple($_)."\"" } @{$unified_info{libraries}}) -}

# DESTDIR is for package builders so that they can configure for, say,
# /usr/ and yet have everything installed to /tmp/somedir/usr/.
# Normally it is left empty.
DESTDIR=

# Do not edit these manually. Use Configure with --prefix or --openssldir
# to change this!  Short explanation in the top comment in Configure
INSTALLTOP={- # $prefix is used in the OPENSSLDIR perl snippet
	      #
	      our $prefix = $config{prefix} || "/usr/local";
              $prefix -}
OPENSSLDIR={- #
	      # The logic here is that if no --openssldir was given,
	      # OPENSSLDIR will get the value from $prefix plus "/ssl".
	      # If --openssldir was given and the value is an absolute
	      # path, OPENSSLDIR will get its value without change.
	      # If the value from --openssldir is a relative path,
	      # OPENSSLDIR will get $prefix with the --openssldir
	      # value appended as a subdirectory.
	      #
              use File::Spec::Functions;
              our $openssldir =
                  $config{openssldir} ?
                      (file_name_is_absolute($config{openssldir}) ?
                           $config{openssldir}
                           : catdir($prefix, $config{openssldir}))
                      : catdir($prefix, "ssl");
              $openssldir -}
LIBDIR={- #
          # if $prefix/lib$target{multilib} is not an existing
          # directory, then assume that it's not searched by linker
          # automatically, in which case adding $target{multilib} suffix
          # causes more grief than we're ready to tolerate, so don't...
          our $multilib =
              -d "$prefix/lib$target{multilib}" ? $target{multilib} : "";
          our $libdir = $config{libdir} || "lib$multilib";
          $libdir -}
ENGINESDIR={- use File::Spec::Functions;
              catdir($prefix,$libdir,"engines") -}

MANDIR=$(INSTALLTOP)/share/man
DOCDIR=$(INSTALLTOP)/share/doc/$(BASENAME)
HTMLDIR=$(DOCDIR)/html

# MANSUFFIX is for the benefit of anyone who may want to have a suffix
# appended after the manpage file section number.  "ssl" is popular,
# resulting in files such as config.5ssl rather than config.5.
MANSUFFIX=
HTMLSUFFIX=html



CROSS_COMPILE= {- $config{cross_compile_prefix} -}
CC= $(CROSS_COMPILE){- $target{cc} -}
CFLAGS={- our $cflags2 = join(" ",(map { "-D".$_} @{$target{defines}}, @{$config{defines}}),"-DOPENSSLDIR=\"\\\"\$(OPENSSLDIR)\\\"\"","-DENGINESDIR=\"\\\"\$(ENGINESDIR)\\\"\"") -} {- $target{cflags} -} {- $config{cflags} -}
CFLAGS_Q={- $cflags2 =~ s|([\\"])|\\$1|g; $cflags2 -} {- $config{cflags} -}
LDFLAGS= {- $target{lflags} -}
PLIB_LDFLAGS= {- $target{plib_lflags} -}
EX_LIBS= {- $target{ex_libs} -} {- $config{ex_libs} -}
LIB_CFLAGS={- $target{shared_cflag} || "" -}
LIB_LDFLAGS={- $target{shared_ldflag}." ".$config{shared_ldflag}
               # Unlike other OSes (like Solaris, Linux, Tru64,
               # IRIX) BSD run-time linkers (tested OpenBSD, NetBSD
               # and FreeBSD) "demand" RPATH set on .so objects.
               # Apparently application RPATH is not global and
               # does not apply to .so linked with other .so.
               # Problem manifests itself when libssl.so fails to
               # load libcrypto.so. One can argue that we should
               # engrave this into Makefile.shared rules or into
               # BSD-* config lines above. Meanwhile let's try to
               # be cautious and pass -rpath to linker only when
               # $prefix is not /usr.
               . ($config{target} =~ m|^BSD-| && $prefix !~ m|^/usr/.*$|
                  ? " -Wl,-rpath,\$\$(LIBRPATH)" : "") -}
RCFLAGS={- $target{shared_rcflag} -}
DSO_CFLAGS={- $target{shared_cflag} || "" -}
DSO_LDFLAGS=$(LIB_LDFLAGS)
BIN_CFLAGS={- "" -}

PERL={- $config{perl} -}

ARFLAGS= {- $target{arflags} -}
AR=$(CROSS_COMPILE){- $target{ar} || "ar" -} $(ARFLAGS) r
RANLIB= {- $target{ranlib} -}
NM= $(CROSS_COMPILE){- $target{nm} || "nm" -}
RM= rm -f
RMDIR= rmdir
TAR= {- $target{tar} || "tar" -}
TARFLAGS= {- $target{tarflags} -}
MAKEDEPEND={- $config{makedepprog} -}

BASENAME=       openssl
NAME=           $(BASENAME)-$(VERSION)
TARFILE=        ../$(NAME).tar

# We let the C compiler driver to take care of .s files. This is done in
# order to be excused from maintaining a separate set of architecture
# dependent assembler flags. E.g. if you throw -mcpu=ultrasparc at SPARC
# gcc, then the driver will automatically translate it to -xarch=v8plus
# and pass it down to assembler.
AS=$(CC) -c
ASFLAG=$(CFLAGS)
PERLASM_SCHEME= {- $target{perlasm_scheme} -}

# For x86 assembler: Set PROCESSOR to 386 if you want to support
# the 80386.
PROCESSOR= {- $config{processor} -}

# The main targets ###################################################

all: configdata.pm build_libs_nodep build_engines_nodep build_apps_nodep \
     depend link-utils

build_libs: configdata.pm build_libs_nodep depend
build_libs_nodep: libcrypto.pc libssl.pc openssl.pc
build_engines: configdata.pm build_engines_nodep depend
build_engines_nodep: $(ENGINES)
build_apps: configdata.pm build_apps_nodep depend
build_apps_nodep: $(PROGRAMS) $(SCRIPTS)
build_tests: configdata.pm build_tests_nodep depend
build_tests_nodep: $(TESTPROGS)

test tests: build_tests_nodep build_apps_nodep build_engines_nodep depend
	( cd test; \
	  SRCTOP=../$(SRCDIR) \
	  BLDTOP=../$(BLDDIR) \
	  EXE_EXT={- $exeext -} \
	  OPENSSL_ENGINES=../$(BLDDIR)/engines \
	    $(PERL) ../$(SRCDIR)/test/run_tests.pl $(TESTS) )

list-tests:
	@TOP=$(SRCDIR) PERL=$(PERL) $(PERL) $(SRCDIR)/test/run_tests.pl list

libclean:
	@set -e; for s in $(SHLIB_INFO); do \
		s1=`echo "$$s" | cut -f1 -d";"`; \
		s2=`echo "$$s" | cut -f2 -d";"`; \
		echo $(RM) $$s1; \
		$(RM) $$s1; \
		if [ "$$s1" != "$$s2" ]; then \
			echo $(RM) $$s2; \
			$(RM) $$s2; \
		fi; \
	done
	$(RM) $(LIBS)

install: install_sw install_ssldirs install_docs

uninstall: uninstall_docs uninstall_sw

clean: libclean
	rm -f $(PROGRAMS) $(TESTPROGS) $(ENGINES) $(SCRIPTS)
	rm -f $(GENERATED)
	-rm -f `find . -name '*{- $depext -}'`
	-rm -f `find . -name '*{- $objext -}'`
	rm -f core
	rm -f tags TAGS
	rm -f openssl.pc libcrypto.pc libssl.pc
	-rm -f `find . -type l`
	rm -f $(TARFILE)

# This exists solely for those who still type 'make depend'
#
# We check if any depfile is newer than Makefile and decide to
# concatenate only if that is true.
depend:
	@: {- output_off() if $disabled{makedepend}; "" -}
	@if [ -z "`find $(DEPS) -newer Makefile 2>/dev/null; exit 0`" ]; then \
	  ( sed -e '/^# DO NOT DELETE THIS LINE.*/,$$d' < Makefile; \
	    echo '# DO NOT DELETE THIS LINE -- make depend depends on it.'; \
	    echo; \
	    for f in $(DEPS); do \
	      if [ -f $$f ]; then cat $$f; fi; \
	    done ) > Makefile.new; \
	  if cmp Makefile.new Makefile >/dev/null 2>&1; then \
	    rm -f Makefile.new; \
	  else \
	    mv -f Makefile.new Makefile; \
	  fi; \
	fi
	@: {- output_on() if $disabled{makedepend}; "" -}

# Install helper targets #############################################

install_sw: all install_dev install_engines install_runtime

uninstall_sw: uninstall_runtime uninstall_engines uninstall_dev

install_docs: install_man_docs install_html_docs

uninstall_docs: uninstall_man_docs uninstall_html_docs
	$(RM) -r -v $(DESTDIR)$(DOCDIR)

install_ssldirs:
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(OPENSSLDIR)/certs
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(OPENSSLDIR)/private

install_dev:
	@[ -n "$(INSTALLTOP)" ] || (echo INSTALLTOP should not be empty; exit 1)
	@echo "*** Installing development files"
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(INSTALLTOP)/include/openssl
	@set -e; for i in $(SRCDIR)/include/openssl/*.h \
			  $(BLDDIR)/include/openssl/*.h; do \
		fn=`basename $$i`; \
		echo "install $$i -> $(DESTDIR)$(INSTALLTOP)/include/openssl/$$fn"; \
		cp $$i $(DESTDIR)$(INSTALLTOP)/include/openssl/$$fn; \
		chmod 644 $(DESTDIR)$(INSTALLTOP)/include/openssl/$$fn; \
	done
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)
	@set -e; for l in $(LIBS); do \
		fn=`basename $$l`; \
		echo "install $$l -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn"; \
		cp $$l $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn.new; \
		$(RANLIB) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn.new; \
		chmod 644 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn.new; \
		mv -f $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn.new \
		      $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn; \
	done
	@ : {- output_off() if $disabled{shared}; "" -}
	@set -e; for s in $(SHLIB_INFO); do \
		s1=`echo "$$s" | cut -f1 -d";"`; \
		s2=`echo "$$s" | cut -f2 -d";"`; \
		fn1=`basename $$s1`; \
		fn2=`basename $$s2`; \
		: {- output_off() if windowsdll(); "" -}; \
		echo "install $$s1 -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1"; \
		cp $$s1 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1.new; \
		chmod 644 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1.new; \
		mv -f $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1.new \
		      $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1; \
		if [ "$$fn1" != "$$fn2" ]; then \
			echo "link $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2 -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1"; \
			ln -sf $$fn1 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2; \
		fi; \
		: {- output_on() if windowsdll(); "" -}{- output_off() unless windowsdll(); "" -}; \
		echo "install $$s2 -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2"; \
		cp $$s2 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2.new; \
		chmod 644 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2.new; \
		mv -f $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2.new \
		      $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2; \
		: {- output_on() unless windowsdll(); "" -}; \
	done
	@ : {- output_on() if $disabled{shared}; "" -}
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
	@echo "install libcrypto.pc -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libcrypto.pc"
	@cp libcrypto.pc $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
	@chmod 644 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libcrypto.pc
	@echo "install libssl.pc -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libssl.pc"
	@cp libssl.pc $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
	@chmod 644 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libssl.pc
	@echo "install openssl.pc -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/openssl.pc"
	@cp openssl.pc $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
	@chmod 644 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/openssl.pc

uninstall_dev:
	@echo "*** Uninstalling development files"
	@set -e; for i in $(SRCDIR)/include/openssl/*.h \
			  $(BLDDIR)/include/openssl/*.h; do \
		fn=`basename $$i`; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/include/openssl/$$fn"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/include/openssl/$$fn; \
	done
	-$(RMDIR) $(DESTDIR)$(INSTALLTOP)/include/openssl
	-$(RMDIR) $(DESTDIR)$(INSTALLTOP)/include
	@set -e; for l in $(LIBS); do \
		fn=`basename $$l`; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn; \
	done
	@ : {- output_off() if $disabled{shared}; "" -}
	@set -e; for s in $(SHLIB_INFO); do \
		s1=`echo "$$s" | cut -f1 -d";"`; \
		s2=`echo "$$s" | cut -f2 -d";"`; \
		fn1=`basename $$s1`; \
		fn2=`basename $$s2`; \
		: {- output_off() if windowsdll(); "" -}; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn1; \
		if [ "$$fn1" != "$$fn2" ]; then \
			echo "$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2"; \
			$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2; \
		fi; \
		: {- output_on() if windowsdll(); "" -}{- output_off() unless windowsdll(); "" -}; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/$$fn2; \
		: {- output_on() unless windowsdll(); "" -}; \
	done
	@ : {- output_on() if $disabled{shared}; "" -}
	$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libcrypto.pc
	$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libssl.pc
	$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/openssl.pc
	-$(RMDIR) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
	-$(RMDIR) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)

install_engines:
	@[ -n "$(INSTALLTOP)" ] || (echo INSTALLTOP should not be empty; exit 1)
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/
	@echo "*** Installing engines"
	@set -e; for e in dummy $(ENGINES); do \
		if [ "$$e" = "dummy" ]; then continue; fi; \
		fn=`basename $$e`; \
		if [ "$$fn" = '{- dso("ossltest") -}' ]; then \
			continue; \
		fi; \
		echo "install $$e -> $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/$$fn"; \
		cp $$e $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/$$fn.new; \
		chmod 755 $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/$$fn.new; \
		mv -f $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/$$fn.new \
		      $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/$$fn; \
	done

uninstall_engines:
	@echo "*** Uninstalling engines"
	@set -e; for e in dummy $(ENGINES); do \
		if [ "$$e" = "dummy" ]; then continue; fi; \
		fn=`basename $$e`; \
		if [ "$$fn" = '{- dso("ossltest") -}' ]; then \
			continue; \
		fi; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/$$fn"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines/$$fn; \
	done
	-$(RMDIR) $(DESTDIR)$(INSTALLTOP)/$(LIBDIR)/engines

install_runtime:
	@[ -n "$(INSTALLTOP)" ] || (echo INSTALLTOP should not be empty; exit 1)
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(INSTALLTOP)/bin
	@$(PERL) $(SRCDIR)/util/mkdir-p.pl $(DESTDIR)$(OPENSSLDIR)/misc
	@echo "*** Installing runtime files"
	: {- output_off() unless windowsdll(); "" -};
	@set -e; for s in dummy $(SHLIBS); do \
		if [ "$$s" = "dummy" ]; then continue; fi; \
		fn=`basename $$s`; \
		echo "install $$s -> $(DESTDIR)$(INSTALLTOP)/bin/$$fn"; \
		cp $$s $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new; \
		chmod 644 $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new; \
		mv -f $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new \
		      $(DESTDIR)$(INSTALLTOP)/bin/$$fn; \
	done
	: {- output_on() unless windowsdll(); "" -};
	@set -e; for x in dummy $(PROGRAMS); do \
		if [ "$$x" = "dummy" ]; then continue; fi; \
		fn=`basename $$x`; \
		echo "install $$x -> $(DESTDIR)$(INSTALLTOP)/bin/$$fn"; \
		cp $$x $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new; \
		chmod 755 $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new; \
		mv -f $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new \
		      $(DESTDIR)$(INSTALLTOP)/bin/$$fn; \
	done
	@set -e; for x in dummy $(BIN_SCRIPTS); do \
		if [ "$$x" = "dummy" ]; then continue; fi; \
		fn=`basename $$x`; \
		echo "install $$x -> $(DESTDIR)$(INSTALLTOP)/bin/$$fn"; \
		cp $$x $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new; \
		chmod 755 $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new; \
		mv -f $(DESTDIR)$(INSTALLTOP)/bin/$$fn.new \
		      $(DESTDIR)$(INSTALLTOP)/bin/$$fn; \
	done
	@set -e; for x in dummy $(MISC_SCRIPTS); do \
		if [ "$$x" = "dummy" ]; then continue; fi; \
		fn=`basename $$x`; \
		echo "install $$x -> $(DESTDIR)$(OPENSSLDIR)/misc/$$fn"; \
		cp $$x $(DESTDIR)$(OPENSSLDIR)/misc/$$fn.new; \
		chmod 755 $(DESTDIR)$(OPENSSLDIR)/misc/$$fn.new; \
		mv -f $(DESTDIR)$(OPENSSLDIR)/misc/$$fn.new \
		      $(DESTDIR)$(OPENSSLDIR)/misc/$$fn; \
	done
	@echo "install $(SRCDIR)/apps/openssl.cnf -> $(DESTDIR)$(OPENSSLDIR)/openssl.cnf"
	@cp $(SRCDIR)/apps/openssl.cnf $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.new
	@chmod 644 $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.new
	@mv -f  $(DESTDIR)$(OPENSSLDIR)/openssl.cnf.new $(DESTDIR)$(OPENSSLDIR)/openssl.cnf

uninstall_runtime:
	@echo "*** Uninstalling runtime files"
	@set -e; for x in dummy $(PROGRAMS); \
	do  \
		if [ "$$x" = "dummy" ]; then continue; fi; \
		fn=`basename $$x`; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/bin/$$fn"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/bin/$$fn; \
	done;
	@set -e; for x in dummy $(BIN_SCRIPTS); \
	do  \
		if [ "$$x" = "dummy" ]; then continue; fi; \
		fn=`basename $$x`; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/bin/$$fn"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/bin/$$fn; \
	done
	@set -e; for x in dummy $(MISC_SCRIPTS); \
	do  \
		if [ "$$x" = "dummy" ]; then continue; fi; \
		fn=`basename $$x`; \
		echo "$(RM) $(DESTDIR)$(OPENSSLDIR)/misc/$$fn"; \
		$(RM) $(DESTDIR)$(OPENSSLDIR)/misc/$$fn; \
	done
	: {- output_off() unless windowsdll(); "" -};
	@set -e; for s in dummy $(SHLIBS); do \
		if [ "$$s" = "dummy" ]; then continue; fi; \
		fn=`basename $$s`; \
		echo "$(RM) $(DESTDIR)$(INSTALLTOP)/bin/$$fn"; \
		$(RM) $(DESTDIR)$(INSTALLTOP)/bin/$$fn; \
	done
	: {- output_on() unless windowsdll(); "" -};
	$(RM) $(DESTDIR)$(OPENSSLDIR)/openssl.cnf
	-$(RMDIR) $(DESTDIR)$(INSTALLTOP)/bin
	-$(RMDIR) $(DESTDIR)$(OPENSSLDIR)/misc

# A method to extract all names from a .pod file
# The first sed extracts everything between "=head1 NAME" and the next =head1
# The perl command joins all the lines into one
# The second sed removes the description and turns all commas into spaces
# VoilÃ , you have a space separated list of names!
EXTRACT_NAMES=sed -e '1,/^=head1  *NAME *$$/d;/^=head1/,$$d' | \
              $(PERL) -p -0 -e 's/\n/ /g; END {print "\n"}' | \
              sed -e 's/ - .*$$//;s/,/ /g'
PROCESS_PODS=\
	set -e; \
	here=`cd $(SRCDIR); pwd`; \
	point=$$here/util/point.sh; \
	for ds in apps:1 crypto:3 ssl:3; do \
	    defdir=`echo $$ds | cut -f1 -d:`; \
	    defsec=`echo $$ds | cut -f2 -d:`; \
	    for p in $(SRCDIR)/doc/$$defdir/*.pod; do \
		SEC=`sed -ne 's/^=for  *comment  *openssl_manual_section: *\([0-9]\) *$$/\1/p' $$p`; \
		[ -z "$$SEC" ] && SEC=$$defsec; \
		fn=`basename $$p .pod`; \
		NAME=`echo $$fn | tr [a-z] [A-Z]`; \
		suf=`eval "echo $$OUTSUFFIX"`; \
		top=`eval "echo $$OUTTOP"`; \
		$(PERL) $(SRCDIR)/util/mkdir-p.pl $$top/man$$SEC; \
		echo "install $$p -> $$top/man$$SEC/$$fn$$suf"; \
		cat $$p | eval "$$GENERATE" \
			>  $$top/man$$SEC/$$fn$$suf; \
		names=`cat $$p | $(EXTRACT_NAMES)`; \
		( cd $$top/man$$SEC; \
		  for n in $$names; do \
		      comp_n="$$n"; \
		      comp_fn="$$fn"; \
		      case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
			  comp_n=`echo "$$n" | tr [A-Z] [a-z]`; \
			  comp_fn=`echo "$$fn" | tr [A-Z] [a-z]`; \
			  ;; \
		      esac; \
		      if [ "$$comp_n" != "$$comp_fn" ]; then \
			  echo "link $$top/man$$SEC/$$n$$suf -> $$top/man$$SEC/$$fn$$suf"; \
			  PLATFORM=$(PLATFORM) $$point $$fn$$suf $$n$$suf; \
		      fi; \
		  done ); \
	    done; \
	done
UNINSTALL_DOCS=\
	set -e; \
	here=`cd $(SRCDIR); pwd`; \
	for ds in apps:1 crypto:3 ssl:3; do \
	    defdir=`echo $$ds | cut -f1 -d:`; \
	    defsec=`echo $$ds | cut -f2 -d:`; \
	    for p in $(SRCDIR)/doc/$$defdir/*.pod; do \
		SEC=`sed -ne 's/^=for  *comment  *openssl_manual_section: *\([0-9]\) *$$/\1/p' $$p`; \
		[ -z "$$SEC" ] && SEC=$$defsec; \
		fn=`basename $$p .pod`; \
		suf=`eval "echo $$OUTSUFFIX"`; \
		top=`eval "echo $$OUTTOP"`; \
		echo "$(RM) $$top/man$$SEC/$$fn$$suf"; \
	        $(RM) $$top/man$$SEC/$$fn$$suf; \
		names=`cat $$p | $(EXTRACT_NAMES)`; \
		for n in $$names; do \
		    comp_n="$$n"; \
		    comp_fn="$$fn"; \
		    case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
			comp_n=`echo "$$n" | tr [A-Z] [a-z]`; \
			comp_fn=`echo "$$fn" | tr [A-Z] [a-z]`; \
			;; \
		    esac; \
		    if [ "$$comp_n" != "$$comp_fn" ]; then \
			echo "$(RM) $$top/man$$SEC/$$n$$suf"; \
			$(RM) $$top/man$$SEC/$$n$$suf; \
		    fi; \
		done; \
		( $(RMDIR) $$top/man$$SEC 2>/dev/null || exit 0 ); \
	    done; \
	done

install_man_docs:
	@[ -n "$(INSTALLTOP)" ] || (echo INSTALLTOP should not be empty; exit 1)
	@echo "*** Installing manpages"
	@\
	OUTSUFFIX='.$${SEC}$(MANSUFFIX)'; \
	OUTTOP="$(DESTDIR)$(MANDIR)"; \
	GENERATE='pod2man --name=$$NAME --section=$$SEC --center=OpenSSL --release=$(VERSION)'; \
	$(PROCESS_PODS)

uninstall_man_docs:
	@echo "*** Uninstalling manpages"
	@\
	OUTSUFFIX='.$${SEC}$(MANSUFFIX)'; \
	OUTTOP="$(DESTDIR)$(MANDIR)"; \
	$(UNINSTALL_DOCS)

install_html_docs:
	@[ -n "$(INSTALLTOP)" ] || (echo INSTALLTOP should not be empty; exit 1)
	@echo "*** Installing HTML manpages"
	@\
	OUTSUFFIX='.$(HTMLSUFFIX)'; \
	OUTTOP="$(DESTDIR)$(HTMLDIR)"; \
	GENERATE="pod2html --podroot=$(SRCDIR)/doc --htmldir=.. \
			   --podpath=apps:crypto:ssl \
		  | sed -e 's|href=\"http://man.he.net/man|href=\"../man|g'"; \
	$(PROCESS_PODS)

uninstall_html_docs:
	@echo "*** Uninstalling manpages"
	@\
	OUTSUFFIX='.$(HTMLSUFFIX)'; \
	OUTTOP="$(DESTDIR)$(HTMLDIR)"; \
	$(UNINSTALL_DOCS)


# Developer targets (note: these are only available on Unix) #########

update: generate errors ordinals

generate: generate_apps generate_crypto_bn generate_crypto_objects

# Test coverage is a good idea for the future
#coverage: $(PROGRAMS) $(TESTPROGRAMS)
#	...

# Currently disabled, util/selftest.pl needs a rewrite
#report:
#	SRCDIR=$(SRCDIR) @$(PERL) util/selftest.pl

lint:
	lint -DLINT $(INCLUDES) $(SRCS)

{- # because the program apps/openssl has object files as sources, and
   # they then have the corresponding C files as source, we need to chain
   # the lookups in %unified_info
   my $apps_openssl = catfile("apps","openssl");
   our @openssl_source = map { @{$unified_info{sources}->{$_}} }
                         @{$unified_info{sources}->{$apps_openssl}};
   ""; -}
generate_apps:
	( cd $(SRCDIR); $(PERL) VMS/VMSify-conf.pl \
				< apps/openssl.cnf > apps/openssl-vms.cnf )
	( b=`pwd`; cd $(SRCDIR); $(PERL) -I$$b apps/progs.pl \
					{- join(" ", @openssl_source) -} \
					> apps/progs.h )

generate_crypto_bn:
	( cd $(SRCDIR); $(PERL) crypto/bn/bn_prime.pl > crypto/bn/bn_prime.h )

generate_crypto_objects:
	( cd $(SRCDIR); $(PERL) crypto/objects/obj_dat.pl \
				include/openssl/obj_mac.h \
				crypto/objects/obj_dat.h )
	( cd $(SRCDIR); $(PERL) crypto/objects/objects.pl \
				crypto/objects/objects.txt \
				crypto/objects/obj_mac.num \
				include/openssl/obj_mac.h )
	( cd $(SRCDIR); $(PERL) crypto/objects/objxref.pl \
				crypto/objects/obj_mac.num \
				crypto/objects/obj_xref.txt \
				> crypto/objects/obj_xref.h )

errors:
	( cd $(SRCDIR); $(PERL) util/ck_errf.pl -strict */*.c */*/*.c )
	( cd $(SRCDIR); $(PERL) util/mkerr.pl -recurse -write )
	( cd $(SRCDIR)/engines; \
	  for e in *.ec; do \
	      $(PERL) ../util/mkerr.pl -conf $$e \
		      -nostatic -staticloader -write *.c; \
	  done )

ordinals:
	( b=`pwd`; cd $(SRCDIR); $(PERL) -I$$b util/mkdef.pl crypto update )
	( b=`pwd`; cd $(SRCDIR); $(PERL) -I$$b util/mkdef.pl ssl update )

test_ordinals:
	( cd test; \
	  SRCTOP=../$(SRCDIR) \
	  BLDTOP=../$(BLDDIR) \
	    $(PERL) ../$(SRCDIR)/test/run_tests.pl test_ordinals )

tags TAGS: FORCE
	rm -f TAGS tags
	-ctags -R .
	-etags `find . -name '*.[ch]' -o -name '*.pm'`

# Release targets (note: only available on Unix) #####################

TAR_COMMAND=$(TAR) $(TARFLAGS) --owner 0 --group 0 -cvf - 
PREPARE_CMD=:
tar:
	TMPDIR=/var/tmp/openssl-copy.$$$$; \
	DISTDIR=$(NAME); \
	mkdir -p $$TMPDIR/$$DISTDIR; \
	(cd $(SRCDIR); \
	 git ls-tree -r --name-only --full-tree HEAD \
	 | while read F; do \
	       mkdir -p $$TMPDIR/$$DISTDIR/`dirname $$F`; \
	       cp $$F $$TMPDIR/$$DISTDIR/$$F; \
	   done); \
	(cd $$TMPDIR; \
	 $(PREPARE_CMD); \
	 find $$TMPDIR/$$DISTDIR -type d -print | xargs chmod 755; \
	 find $$TMPDIR/$$DISTDIR -type f -print | xargs chmod a+r; \
	 find $$TMPDIR/$$DISTDIR -type f -perm -0100 -print | xargs chmod a+x; \
	 $(TAR_COMMAND) $$DISTDIR) \
	| (cd $(SRCDIR); gzip --best > $(TARFILE).gz); \
	rm -rf $$TMPDIR
	cd $(SRCDIR); ls -l $(TARFILE).gz

dist:
	@$(MAKE) PREPARE_CMD='./Configure dist' tar

# Helper targets #####################################################

link-utils: $(BLDDIR)/util/opensslwrap.sh $(BLDDIR)/util/shlib_wrap.sh

$(BLDDIR)/util/opensslwrap.sh: configdata.pm
	@if [ "$(SRCDIR)" != "$(BLDDIR)" ]; then \
	    mkdir -p "$(BLDDIR)/util"; \
	    ln -sf "../$(SRCDIR)/util/opensslwrap.sh" "$(BLDDIR)/util"; \
	fi
$(BLDDIR)/util/shlib_wrap.sh: configdata.pm
	@if [ "$(SRCDIR)" != "$(BLDDIR)" ]; then \
	    mkdir -p "$(BLDDIR)/util"; \
	    ln -sf "../$(SRCDIR)/util/shlib_wrap.sh" "$(BLDDIR)/util"; \
	fi

FORCE:

# Building targets ###################################################

libcrypto.pc libssl.pc openssl.pc: configdata.pm $(LIBS)
libcrypto.pc:
	@ ( echo 'prefix=$(INSTALLTOP)'; \
	    echo 'exec_prefix=$${prefix}'; \
	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
	    echo 'includedir=$${prefix}/include'; \
	    echo ''; \
	    echo 'Name: OpenSSL-libcrypto'; \
	    echo 'Description: OpenSSL cryptography library'; \
	    echo 'Version: '$(VERSION); \
	    echo 'Libs: -L$${libdir} -lcrypto'; \
	    echo 'Libs.private: $(EX_LIBS)'; \
	    echo 'Cflags: -I$${includedir}' ) > libcrypto.pc

libssl.pc:
	@ ( echo 'prefix=$(INSTALLTOP)'; \
	    echo 'exec_prefix=$${prefix}'; \
	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
	    echo 'includedir=$${prefix}/include'; \
	    echo ''; \
	    echo 'Name: OpenSSL-libssl'; \
	    echo 'Description: Secure Sockets Layer and cryptography libraries'; \
	    echo 'Version: '$(VERSION); \
	    echo 'Requires.private: libcrypto'; \
	    echo 'Libs: -L$${libdir} -lssl'; \
	    echo 'Libs.private: $(EX_LIBS)'; \
	    echo 'Cflags: -I$${includedir}' ) > libssl.pc

openssl.pc:
	@ ( echo 'prefix=$(INSTALLTOP)'; \
	    echo 'exec_prefix=$${prefix}'; \
	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
	    echo 'includedir=$${prefix}/include'; \
	    echo ''; \
	    echo 'Name: OpenSSL'; \
	    echo 'Description: Secure Sockets Layer and cryptography libraries and tools'; \
	    echo 'Version: '$(VERSION); \
	    echo 'Requires: libssl libcrypto' ) > openssl.pc

# Note on the use of $(MFLAGS): this was an older variant of MAKEFLAGS which
# wasn't passed down automatically.  It's quite safe to use it like we do
# below; if it doesn't exist, the result will be empty and 'make' will pick
# up $(MAKEFLAGS) which is passed down as an environment variable.
configdata.pm: $(SRCDIR)/Configurations/unix-Makefile.tmpl $(SRCDIR)/Configurations/common.tmpl $(SRCDIR)/Configure $(SRCDIR)/config {- join(" ", @{$config{build_infos}}) -}
	@echo "Detected changed: $?"
	@echo "Reconfiguring..."
	$(SRCDIR)/Configure reconf
	@echo "**************************************************"
	@echo "***                                            ***"
	@echo "***   Please run the same make command again   ***"
	@echo "***                                            ***"
	@echo "**************************************************"
	@false

{-
  use File::Basename;
  use File::Spec::Functions qw/:DEFAULT abs2rel rel2abs/;

  # Helper function to figure out dependencies on libraries
  # It takes a list of library names and outputs a list of dependencies
  sub compute_lib_depends {
      if ($disabled{shared}) {
          return map { $_.$libext } @_;
      }

      # Depending on shared libraries:
      # On Windows POSIX layers, we depend on {libname}.dll.a
      # On Unix platforms, we depend on {shlibname}.so
      return map { shlib_simple($_) } @_;
  }

  sub generatesrc {
      my %args = @_;
      my $generator = join(" ", @{$args{generator}});
      my $incs = join("", map { " -I".$_ } @{$args{incs}});
      my $deps = join(" ", @{$args{deps}});

      if ($args{src} !~ /\.[sS]$/) {
          return <<"EOF";
$args{src}: $args{generator}->[0] $deps
	\$(PERL) $generator > \$@
EOF
      } else {
          if ($args{generator}->[0] =~ /\.pl$/) {
              $generator = 'CC="$(CC)" $(PERL) '.$generator;
          } elsif ($args{generator}->[0] =~ /\.m4$/) {
              $generator = 'm4 -B 8192 '.$generator.' >'
          } elsif ($args{generator}->[0] =~ /\.S$/) {
              $generator = undef;
          } else {
              die "Generator type for $args{src} unknown: $generator\n";
          }

          if (defined($generator)) {
              # If the target is named foo.S in build.info, we want to
              # end up generating foo.s in two steps.
              if ($args{src} =~ /\.S$/) {
                   (my $target = $args{src}) =~ s|\.S$|.s|;
                   return <<"EOF";
$target: $args{generator}->[0] $deps
	( trap "rm -f \$@.*" INT 0; \\
	  $generator \$@.S; \\
	  \$(CC) \$(CFLAGS) $incs -E -P \$@.S > \$@.i && mv -f \$@.i \$@ )
EOF
              }
              # Otherwise....
              return <<"EOF";
$args{src}: $args{generator}->[0] $deps
	$generator \$@
EOF
          }
          return <<"EOF";
$args{src}: $args{generator}->[0] $deps
	\$(CC) \$(CFLAGS) $incs -E -P \$< > \$@
EOF
      }
  }

  # Should one wonder about the end of the Perl snippet, it's because this
  # second regexp eats up line endings as well, if the removed path is the
  # last in the line.  We may therefore need to put back a line ending.
  sub src2obj {
      my %args = @_;
      my $obj = $args{obj};
      my @srcs = map { if ($unified_info{generate}->{$_}) {
                           (my $x = $_) =~ s/\.S$/.s/; $x
                       } else {
                           $_
                       }
                     } ( @{$args{srcs}} );
      my $srcs = join(" ",  @srcs);
      my $deps = join(" ", @srcs, @{$args{deps}});
      my $incs = join("", map { " -I".$_ } @{$args{incs}});
      my $ecflags = { lib => '$(LIB_CFLAGS)',
                      dso => '$(DSO_CFLAGS)',
                      bin => '$(BIN_CFLAGS)' } -> {$args{intent}};
      my $makedepprog = $config{makedepprog};
      my $recipe = "";
      if (!$disabled{makedepend} && $makedepprog =~ /\/makedepend/) {
          $recipe .= <<"EOF";
$obj$depext: $deps
	-\$(MAKEDEPEND) -f- -o"|$obj$objext" -- \$(CFLAGS) $ecflags$incs -- $srcs \\
	    >\$\@.tmp 2>/dev/null
	-\$(PERL) -i -pe 's/^.*\\|//; s/ \\/(\\\\.|[^ ])*//; \$\$_ = undef if (/: *\$\$/ || /^(#.*| *)\$\$/); \$\$_.="\\n" unless !defined(\$\$_) or /\\R\$\$/g;' \$\@.tmp
	\@if cmp \$\@.tmp \$\@ > /dev/null 2> /dev/null; then \\
		rm -f \$\@.tmp; \\
	else \\
		mv \$\@.tmp \$\@; \\
	fi
EOF
          $deps = $obj.$depext;
      }
      if ($disabled{makedepend} || $makedepprog =~ /\/makedepend/) {
          $recipe .= <<"EOF";
$obj$objext: $deps
	\$(CC) \$(CFLAGS) $ecflags$incs -c -o \$\@ $srcs
EOF
      }
      if (!$disabled{makedepend} && $makedepprog !~ /\/makedepend/) {
          $recipe .= <<"EOF";
$obj$objext: $deps
	\$(CC) \$(CFLAGS) $ecflags$incs -MMD -MF $obj$depext.tmp -MT \$\@ -c -o \$\@ $srcs
	\@touch $obj$depext.tmp
	\@if cmp $obj$depext.tmp $obj$depext > /dev/null 2> /dev/null; then \\
		rm -f $obj$depext.tmp; \\
	else \\
		mv $obj$depext.tmp $obj$depext; \\
	fi
EOF
      }
      return $recipe;
  }
  # On Unix, we build shlibs from static libs, so we're ignoring the
  # object file array.  We *know* this routine is only called when we've
  # configure 'shared'.
  sub libobj2shlib {
      my %args = @_;
      my $lib = $args{lib};
      my $shlib = $args{shlib};
      my $libd = dirname($lib);
      my $libn = basename($lib);
      (my $libname = $libn) =~ s/^lib//;
      my $linklibs = join("", map { my $d = dirname($_);
                                    my $f = basename($_);
                                    (my $l = $f) =~ s/^lib//;
                                    " -L$d -l$l" } @{$args{deps}});
      my $deps = join(" ",compute_lib_depends(@{$args{deps}}));
      my $shlib_target = $target{shared_target};
      my $ordinalsfile = defined($args{ordinals}) ? $args{ordinals}->[1] : "";
      my $target = shlib_simple($lib);
      return <<"EOF"
# With a build on a Windows POSIX layer (Cygwin or Mingw), we know for a fact
# that two files get produced, {shlibname}.dll and {libname}.dll.a.
# With all other Unix platforms, we often build a shared library with the
# SO version built into the file name and a symlink without the SO version
# It's not necessary to have both as targets.  The choice falls on the
# simplest, {libname}$shlibextimport for Windows POSIX layers and
# {libname}$shlibextsimple for the Unix platforms.
$target: $lib$libext $deps $ordinalsfile
	\$(MAKE) -f \$(SRCDIR)/Makefile.shared -e \\
		PLATFORM=\$(PLATFORM) \\
		PERL=\$(PERL) SRCDIR='\$(SRCDIR)' DSTDIR="$libd" \\
		INSTALLTOP='\$(INSTALLTOP)' LIBDIR='\$(LIBDIR)' \\
		LIBDEPS='\$(PLIB_LDFLAGS) '"$linklibs"' \$(EX_LIBS)' \\
		LIBNAME=$libname LIBVERSION=\$(SHLIB_MAJOR).\$(SHLIB_MINOR) \\
		LIBCOMPATVERSIONS=';\$(SHLIB_VERSION_HISTORY)' \\
		CC='\$(CC)' CFLAGS='\$(CFLAGS) \$(LIB_CFLAGS)' \\
		CROSS_COMPILE='\$(CROSS_COMPILE)' LDFLAGS='\$(LDFLAGS)' \\
		SHARED_LDFLAGS='\$(LIB_LDFLAGS)' SHLIB_EXT=$shlibext \\
		SHARED_RCFLAGS='\$(RCFLAGS)' \\
		link_shlib.$shlib_target
EOF
	  . (windowsdll() ? <<"EOF" : "");
	rm -f apps/$shlib$shlibext
	rm -f test/$shlib$shlibext
	cp -p $shlib$shlibext apps/
	cp -p $shlib$shlibext test/
EOF
  }
  sub obj2dso {
      my %args = @_;
      my $lib = $args{lib};
      my $libd = dirname($lib);
      my $libn = basename($lib);
      (my $libname = $libn) =~ s/^lib//;
      my $shlibdeps = join("", map { my $d = dirname($_);
                                     my $f = basename($_);
                                     (my $l = $f) =~ s/^lib//;
                                     " -L$d -l$l" } @{$args{deps}});
      my $deps = join(" ",compute_lib_depends(@{$args{deps}}));
      my $shlib_target = $target{shared_target};
      my $objs = join(" ", map { $_.$objext } @{$args{objs}});
      my $target = dso($lib);
      return <<"EOF";
$target: $objs $deps
	\$(MAKE) -f \$(SRCDIR)/Makefile.shared -e \\
		PLATFORM=\$(PLATFORM) \\
		PERL=\$(PERL) SRCDIR='\$(SRCDIR)' DSTDIR="$libd" \\
		LIBDEPS='\$(PLIB_LDFLAGS) '"$shlibdeps"' \$(EX_LIBS)' \\
		LIBNAME=$libname LDFLAGS='\$(LDFLAGS)' \\
		CC='\$(CC)' CFLAGS='\$(CFLAGS) \$(DSO_CFLAGS)' \\
		SHARED_LDFLAGS='\$(DSO_LDFLAGS)' \\
		SHLIB_EXT=$dsoext \\
		LIBEXTRAS="$objs" \\
		link_dso.$shlib_target
EOF
  }
  sub obj2lib {
      my %args = @_;
      my $lib = $args{lib};
      my $objs = join(" ", map { $_.$objext } @{$args{objs}});
      return <<"EOF";
$lib$libext: $objs
	\$(AR) \$\@ $objs
	\$(RANLIB) \$\@ || echo Never mind.
EOF
  }
  sub obj2bin {
      my %args = @_;
      my $bin = $args{bin};
      my $bind = dirname($bin);
      my $binn = basename($bin);
      my $objs = join(" ", map { $_.$objext } @{$args{objs}});
      my $deps = join(" ",compute_lib_depends(@{$args{deps}}));
      my $linklibs = join("", map { my $d = dirname($_);
                                    my $f = basename($_);
                                    $d = "." if $d eq $f;
                                    (my $l = $f) =~ s/^lib//;
                                    " -L$d -l$l" } @{$args{deps}});
      my $shlib_target = $disabled{shared} ? "" : $target{shared_target};
      return <<"EOF";
$bin$exeext: $objs $deps
	\$(RM) $bin$exeext
	\$(MAKE) -f \$(SRCDIR)/Makefile.shared -e \\
		PERL=\$(PERL) SRCDIR=\$(SRCDIR) \\
		APPNAME=$bin$exeext OBJECTS="$objs" \\
		LIBDEPS='\$(PLIB_LDFLAGS) '"$linklibs"' \$(EX_LIBS)' \\
		CC='\$(CC)' CFLAGS='\$(CFLAGS) \$(BIN_CFLAGS)' \\
		LDFLAGS='\$(LDFLAGS)' LIBRPATH='\$(INSTALLTOP)/\$(LIBDIR)' \\
		link_app.$shlib_target
EOF
  }
  sub in2script {
      my %args = @_;
      my $script = $args{script};
      my $sources = join(" ", @{$args{sources}});
      my $dofile = abs2rel(rel2abs(catfile($config{sourcedir},
                                           "util", "dofile.pl")),
                           rel2abs($config{builddir}));
      return <<"EOF";
$script: $sources
	\$(PERL) "-I\$(BLDDIR)" -Mconfigdata "$dofile" \\
	    "-o$target{build_file}" $sources > "$script"
	chmod a+x $script
EOF
  }
  ""    # Important!  This becomes part of the template result.
-}
