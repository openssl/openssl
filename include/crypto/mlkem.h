/*
 * Copyright 2024 The OpenSSL Project Authors. All Rights Reserved.
 *
 * Licensed under the Apache License 2.0 (the "License").  You may not use
 * this file except in compliance with the License.  You can obtain a copy
 * in the file LICENSE in the source distribution or at
 * https://www.openssl.org/source/license.html
 */

/* Copyright (c) 2024, Google Inc. */

#ifndef OPENSSL_HEADER_MLKEM_H
# define OPENSSL_HEADER_MLKEM_H

# include <stdint.h>
# include <openssl/e_os2.h>
# include <crypto/evp.h>

# if defined(__cplusplus)
extern "C" {
# endif

# ifndef OPENSSL_NO_MLKEM

    typedef struct ossl_mlkem_ctx {
        EVP_MD *shake128_cache;
        EVP_MD *shake256_cache;
        EVP_MD *sha3_256_cache;
        EVP_MD *sha3_512_cache;
        OSSL_LIB_CTX *libctx;
        char *properties;
    } ossl_mlkem_ctx;

    /* General ctx functions */
    ossl_mlkem_ctx *ossl_mlkem_newctx(OSSL_LIB_CTX *libctx, const char *properties);

    void ossl_mlkem_ctx_free(ossl_mlkem_ctx *ctx);

    /*
     * ML-KEM-768.
     *
     * This implements the Module-Lattice-Based Key-Encapsulation Mechanism from
     * https://csrc.nist.gov/pubs/fips/203/final
     */

    /*
     * ossl_mlkem768_public_key contains an ML-KEM-768 public key. The contents of this
     * object should never leave the address space since the format is unstable.
     */

    /* TODO: Review alignment as per https://github.com/openssl/private/issues/702 */

    typedef struct ossl_mlkem768_public_key {
        union {
            uint8_t bytes[512 * (3 + 9) + 32 + 32];
            uint16_t alignment;
        } opaque;
    } ossl_mlkem768_public_key;

    /*
     * ossl_mlkem768_private_key contains an ML-KEM-768 private key. The contents of this
     * object should never leave the address space since the format is unstable.
     */
    typedef struct ossl_mlkem768_private_key {
        union {
            uint8_t bytes[512 * (3 + 3 + 9) + 32 + 32 + 32];
            uint16_t alignment;
        } opaque;
    } ossl_mlkem768_private_key;

/*
 * Parameters from FIPS 203 Section 8: Parameter Sets
 * Reference: https://csrc.nist.gov/pubs/fips/203/final
 */

#  define OSSL_MLKEM768_SECURITY_BITS 192

  /*
   * OSSL_MLKEM1024_PUBLIC_KEY_BYTES is the number of bytes in an encoded ML-KEM-1024
   * public key.
   */
#  define OSSL_MLKEM1024_PUBLIC_KEY_BYTES 1568

  /*
   * OSSL_MLKEM768_PUBLIC_KEY_BYTES is the number of bytes in an encoded ML-KEM-768
   * public key.
   */
#  define OSSL_MLKEM768_PUBLIC_KEY_BYTES 1184

  /* MLKEM_SEED_BYTES is the number of bytes in an ML-KEM seed. */
#  define MLKEM_SEED_BYTES 64

    /*
     * ossl_mlkem768_generate_key generates a random public/private key pair, writes the
     * encoded public key to |out_encoded_public_key| and sets |out_private_key| to
     * the private key. If |optional_out_seed| is not NULL then the seed used to
     * generate the private key is written to it as well.
     * out_encoded_public_key must be allocated to store ossl_mlkem768_PUBLIC_KEY_BYTES
     * optional_out_seed if not NULL must be allocated to store MLKEM_SEED_BYTES
     */
    int ossl_mlkem768_generate_key(uint8_t *out_encoded_public_key,
                                   uint8_t *optional_out_seed,
                                   struct ossl_mlkem768_private_key *out_private_key,
                                   ossl_mlkem_ctx *mlkem_ctx);

    /*
     * ossl_mlkem768_private_key_from_seed derives a private key from a seed that was
     * generated by |ossl_mlkem768_generate_key|. It fails and returns 0 if |seed_len| is
     * incorrect, otherwise it writes |*out_private_key| and returns 1.
     */
    int ossl_mlkem768_private_key_from_seed(ossl_mlkem768_private_key *out_private_key,
                                            const uint8_t *seed,
                                            size_t seed_len,
                                            ossl_mlkem_ctx *mlkem_ctx);

    /*
     * ossl_mlkem768_public_from_private sets |*out_public_key| to the public key that
     * corresponds to |private_key|. (This is faster than parsing the output of
     * |ossl_mlkem768_generate_key| if, for some reason, you need to encapsulate to a key
     * that was just generated.)
     */
    int ossl_mlkem768_public_from_private(ossl_mlkem768_public_key *out_public_key,
                                          const ossl_mlkem768_private_key *private_key);

  /* ossl_mlkem1024_CIPHERTEXT_BYTES is number of bytes in the ML-KEM-1024 ciphertext. */
#  define OSSL_MLKEM1024_CIPHERTEXT_BYTES 1568

  /* ossl_mlkem768_CIPHERTEXT_BYTES is number of bytes in the ML-KEM-768 ciphertext. */
#  define OSSL_MLKEM768_CIPHERTEXT_BYTES 1088

  /* ossl_mlkem768_SHARED_SECRET_BYTES is the number of bytes in an ML-KEM shared secret. */
#  define OSSL_MLKEM768_SHARED_SECRET_BYTES 32

    /*
     * ossl_mlkem768_encap encrypts a random shared secret for |public_key|, writes the
     * ciphertext to |out_ciphertext|, and writes the random shared secret to
     * |out_shared_secret|.
     * it is assumed out_ciphertext has been allocated ossl_mlkem768_CIPHERTEXT_BYTES bytes
     * and out_shared_secret has been allocated MLKEM_SHARED_SECRET_BYTES bytes
     */
    int ossl_mlkem768_encap(uint8_t *out_ciphertext,
                            uint8_t *out_shared_secret,
                            const ossl_mlkem768_public_key *public_key,
                            ossl_mlkem_ctx *mlkem_ctx);

    /*
     * ossl_mlkem768_decap decrypts a shared secret from |ciphertext| using |private_key|
     * and writes it to |out_shared_secret|. If |ciphertext_len| is incorrect it
     * returns 0, otherwise it returns 1. If |ciphertext| is invalid (but of the
     * correct length), |out_shared_secret| is filled with a key that will always be
     * the same for the same |ciphertext| and |private_key|, but which appears to be
     * random unless one has access to |private_key|. These alternatives occur in
     * constant time. Any subsequent symmetric encryption using |out_shared_secret|
     * must use an authenticated encryption scheme in order to discover the
     * decapsulation failure.
     * it is assumed out_shared_secret has been allocated MLKEM_SHARED_SECRET_BYTES bytes
     */
    int ossl_mlkem768_decap(uint8_t *out_shared_secret,
                            const uint8_t *ciphertext, size_t ciphertext_len,
                            const ossl_mlkem768_private_key *private_key,
                            ossl_mlkem_ctx *mlkem_ctx);

    /*
     * ossl_mlkem768_recreate_public_key recreates a fully formed ossl_mlkem768_public_key
     * from an input |encoded_public_key| of size ossl_mlkem768_PUBLIC_KEY_BYTES.
     * |pub| is expected to point to an allocated memory area of
     * sizeof(ossl_mlkem768_public_key)
     */
    int ossl_mlkem768_recreate_public_key(const uint8_t *encoded_public_key,
                                          ossl_mlkem768_public_key *pub,
                                          ossl_mlkem_ctx *mlkem_ctx);

# endif /* OPENSSL_NO_MLKEM */

# if defined(__cplusplus)
}  /* extern C */
# endif

#endif  /* OPENSSL_HEADER_MLKEM_H */
