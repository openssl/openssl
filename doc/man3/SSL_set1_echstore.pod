=pod

=head1 NAME

SSL_set1_echstore,
OSSL_ECHSTORE_new, OSSL_ECHSTORE_free,
OSSL_ECHSTORE_new_config, OSSL_ECHSTORE_write_pem,
OSSL_ECHSTORE_read_echconfiglist, OSSL_ECHSTORE_get1_info,
OSSL_ECHSTORE_downselect, OSSL_ECHSTORE_set1_key_and_read_pem,
OSSL_ECHSTORE_read_pem, OSSL_ECHSTORE_num_entries,
OSSL_ECHSTORE_num_keys, OSSL_ECHSTORE_flush_keys,
SSL_CTX_set1_echstore,
SSL_CTX_get1_echstore, SSL_get1_echstore, SSL_ech_set1_server_names,
SSL_ech_set1_outer_server_name, SSL_ech_set1_outer_alpn_protos,
SSL_ech_get1_status, SSL_ech_set1_grease_suite, SSL_ech_set_grease_type,
SSL_ech_set_callback, SSL_ech_get1_retry_config,
SSL_CTX_ech_set1_outer_alpn_protos, SSL_CTX_ech_raw_decrypt,
SSL_CTX_ech_set_callback,SSL_set1_ech_config_list
- Encrypted Client Hello (ECH) functions

=head1 SYNOPSIS

 #include <openssl/ech.h>

  OSSL_ECHSTORE *OSSL_ECHSTORE_new(OSSL_LIB_CTX *libctx, const char *propq);
  void OSSL_ECHSTORE_free(OSSL_ECHSTORE *es);
  int OSSL_ECHSTORE_new_config(OSSL_ECHSTORE *es,
                               uint16_t echversion, uint16_t max_name_length,
                               const char *public_name, OSSL_HPKE_SUITE suite);
  int OSSL_ECHSTORE_write_pem(OSSL_ECHSTORE *es, int index, BIO *out);
  int OSSL_ECHSTORE_read_echconfiglist(OSSL_ECHSTORE *es, BIO *in);
  int OSSL_ECHSTORE_get1_info(OSSL_ECHSTORE *es, int index, time_t *loaded_secs,
                              char **public_name, char **echconfig,
                              int *has_private, int *for_retry);
  int OSSL_ECHSTORE_downselect(OSSL_ECHSTORE *es, int index);
  int OSSL_ECHSTORE_set1_key_and_read_pem(OSSL_ECHSTORE *es, EVP_PKEY *priv,
                                          BIO *in, int for_retry);
  int OSSL_ECHSTORE_read_pem(OSSL_ECHSTORE *es, BIO *in, int for_retry);
  int OSSL_ECHSTORE_num_entries(OSSL_ECHSTORE *es, int *numentries);
  int OSSL_ECHSTORE_num_keys(OSSL_ECHSTORE *es, int *numkeys);
  int OSSL_ECHSTORE_flush_keys(OSSL_ECHSTORE *es, time_t age);
  int SSL_CTX_set1_echstore(SSL_CTX *ctx, OSSL_ECHSTORE *es);
  int SSL_set1_echstore(SSL *s, OSSL_ECHSTORE *es);
  OSSL_ECHSTORE *SSL_CTX_get1_echstore(const SSL_CTX *ctx);
  OSSL_ECHSTORE *SSL_get1_echstore(const SSL *s);
  int SSL_ech_set1_server_names(SSL *s, const char *inner_name,
                                const char *outer_name, int no_outer);
  int SSL_ech_set1_outer_server_name(SSL *s, const char *outer_name, int no_outer);
  int SSL_ech_set1_outer_alpn_protos(SSL *s, const unsigned char *protos,
                                     const size_t protos_len);
  int SSL_ech_get1_status(SSL *s, char **inner_sni, char **outer_sni);
  int SSL_ech_set1_grease_suite(SSL *s, const char *suite);
  int SSL_ech_set_grease_type(SSL *s, uint16_t type);
  void SSL_ech_set_callback(SSL *s, SSL_ech_cb_func f);
  int SSL_ech_get1_retry_config(SSL *s, unsigned char **ec, size_t *eclen);
  int SSL_CTX_ech_raw_decrypt(SSL_CTX *ctx,
                              int *decrypted_ok,
                              char **inner_sni, char **outer_sni,
                              unsigned char *outer_ch, size_t outer_len,
                              unsigned char *inner_ch, size_t *inner_len,
                              unsigned char **hrrtok, size_t *toklen);
  void SSL_CTX_ech_set_callback(SSL_CTX *ctx, SSL_ech_cb_func f);
  int SSL_CTX_ech_set1_outer_alpn_protos(SSL_CTX *ctx,
                                         const unsigned char *protos,
                                         const size_t protos_len);
  int SSL_set1_ech_config_list(SSL *ssl, const uint8_t *ecl, size_t ecl_len);

=head1 DESCRIPTION

TODO(ECH): Replace XXXX with issued RFC number.

The Encrypted Client Hello (ECH) APIs described here are built around
the concept of an B<OSSL_ECHSTORE> which contains ECH configuration
information relevant for the current B<SSL_CTX> or B<SSL> connection.

=head2 OSSL_ECHSTORE APIs

The externally opaque type B<OSSL_ECHSTORE> allows applications to create and
manage ECHConfigList values, ECH private keys and associated meta-data. The
external APIs using B<OSSL_ECHSTORE> are:

OSSL_ECHSTORE_new() and OSSL_ECHSTORE_free() create and free the
internal storage required.

OSSL_ECHSTORE_new_config() allows the caller to create a new private key
value and a related "singleton" ECHConfigList structure.
("Singleton" meaning the ECHConfigList only contains one public key.)

OSSL_ECHSTORE_write_pem() allows the caller to produce a "PEM" data structure
(conforming to the ECH PEM file format) from the B<OSSL_ECHSTORE> entry
identified by the I<index>. (An I<index> of B<OSSL_ECHSTORE_LAST> will select the
last entry. An I<index> of B<OSSL_ECHSTORE_ALL> will output all public values,
and no private values.) These two APIs will typically be used via the "openssl
ech" command line tool.

OSSL_ECHSTORE_read_echconfiglist() will typically be used by a client to
ingest the "ech=" SvcParamKey value found in an SVCB or HTTPS RR retrieved from
the DNS. The resulting set of ECHConfig values can then be associated with an
B<SSL_CTX> or B<SSL> structure for TLS connections.

OSSL_ECHSTORE_get1_info() presents the caller with information about the
content of the store for logging or for display, e.g. in a command line tool.
OSSL_ECHSTORE_downselect() API gives the client a way to select one
particular ECHConfig value from the set stored (discarding the rest).

OSSL_ECHSTORE_set1_key_and_read_pem() and OSSL_ECHSTORE_read_pem() can be used
to load a private key value and associated ECHConfigList into an
B<OSSL_ECHSTORE> structure.  Those can be used (by servers) to enable ECH for
an B<SSL_CTX> or B<SSL> connection. In addition to loading those values, the
application can also indicate via I<for_retry> which ECHConfig values are to be
included in the I<retry_configs> fallback scheme defined by the ECH protocol.
An ECH PEM file may contain a private key and an ECHConfigList with more than
one ECHConfig, for example if different public keys, I<public_name> values, or
AEAD/KDF settings are to be supported. In such cases the resulting
B<OSSL_ECHSTORE> will contain one entry for each ECHConfig, so will be a set of
"singleton" ECHConfig values, with the private key associated with each
matching public key value.

OSSL_ECHSTORE_num_entries() and OSSL_ECHSTORE_num_keys() allow an
application  to see how many usable ECH configs and private keys are currently
in the store, and OSSL_ECHSTORE_flush_keys() allows a server to flush keys
that are older than I<age> seconds.  The general model is that a server can
maintain an B<OSSL_ECHSTORE> into which it periodically loads the "latest" set
of keys, e.g.  hourly, and also discards the keys that are too old, e.g. more
than 3 hours old. This allows for more robust private key management even if
public key distribution suffers temporary failures.

SSL_CTX_set1_echstore() and SSL_set1_echstore()
allow clients and servers to associate an B<OSSL_ECHSTORE>
with an B<SSL_CTX> or B<SSL> structure.
ECH will be enabled for the relevant B<SSL_CTX> or B<SSL> connection
when these functions succeed. Any previously associated B<OSSL_ECHSTORE>
will be freed via OSSL_ECHSTORE_free().

SSL_CTX_get1_echstore() and SSL_get1_echstore()
provide access to the B<OSSL_ECHSTORE> associated with an B<SSL_CTX> or
B<SSL> connection.
The resulting B<OSSL_ECHSTORE> can be modified and then re-associated
with an B<SSL_CTX> or B<SSL> connection.

=head2 Client ECH Controls

SSL_set1_ech_config_list() allows setting an ECHConfigList for a client SSL
connection, and is compatible with current BoringSSL APIs, allowing for smaller
code changes for clients that support OpenSSL or BoringSSL. Note that the input
I<ecl> here for OpenSSL can be either base64 or binary encoded, but for
BoringSSL it must be binary encoded.

SSL_ech_set1_server_names() SSL_ech_set1_outer_server_name() allow clients to
more directly control the values to be used for inner and outer SNI values, for
example allowing a client to override the I<public_name> present in an
ECHConfigList that will otherwise be used for the outer ClientHello SNI. The
I<no_outer> input allows a client to emit an outer ClientHello with no SNI at
all. Providing a B<NULL> for the I<outer_name> means to send the I<public_name>
provided from the ECHConfigList.

If a client has called L<SSL_CTX_set_alpn_protos> or L<SSL_set_alpn_protos>
then the ALPN value will be the same in the inner and outer ClientHello
messages.
SSL_ech_set1_outer_alpn_protos() and SSL_CTX_ech_set1_outer_alpn_protos()
allow clients to set a specific value for the ALPN sent in the outer
ClientHello

If a client attempts ECH but that fails, or sends an ECH-GREASEd ClientHello, to an
ECH-supporting server, then that server may return an ECH I<retry-config> value
that the client could choose to use in a subsequent connection. The client can
detect this situation via the SSL_ech_get1_status() API and can access the
retry config value via SSL_ech_get1_retry_config().

"GREASEing" (defined in RFC8701) is a mechanism
intended to discourage protocol ossification that can be used for ECH.

SSL_ech_set1_grease_suite() and SSL_ech_set_grease_type() allow a client to
GREASE using  a specific HPKE suite or ECH version (represented by the TLS
extension type code-point).

Clients and servers can query the status of ECH for a TLS session using the
SSL_ech_get1_status() function. As SNI handling is core to ECH this will return
the I<inner_sni> and I<outer_sni> values to be used or that were used as well
as a status code as the return value. (These must be freed by the caller.)
The various status values are as shown in L</Constants>.

=head2 Callback Functions

Applications can set a callback function that will be called when the
outcome from an attempt at ECH has been determined. On the server,
that happens early, as part of construction of the ServerHello message.
On the client, the callback will happen after the SeverHello has
been processed. In the event of HelloRetryRequest, the callback will
only be triggered when processing the second ServerHello. The callback
function will be triggered even if the client is only GREASEing.

The callback function prototype is:

  typedef unsigned int (*SSL_ech_cb_func)(SSL *s, const char *str);

To set a callback function use SSL_ech_set_callback() or
SSL_CTX_ech_set_callback() - the I<f> input should match the
above prototype.

When the callback function is called, the I<str> will point at a string
intended for logging describing the state of ECH processing.
Applications should not attempt to parse that string as the value depends
on compile time settings, local configuration and the specific processing
that happened prior to the callback. Applications that need to branch based
on the outcome of ECH processing should instead make a call to
SSL_ech_get1_status() from within their callback function.

An example string I<str> as seen on a client might be:

 ech_attempted=1
 ech_attempted_type=0xfe0d
 ech_atttempted_cid=0x5d
 ech_done=1
 ech_grease=0
 ech_returned_len=0
 ech_backend=0
 ech_success=1
 2 ECHConfig values loaded
 cfg(0): [fe0d,5d,cover.defo.ie,0020,[0001,0001],190984309c1a24cb944c005eb79d9c72ca9a4a979194b553dfd0bffc6b5c152d,00,00]
 cfg(1): [fe0d,fd,cover.defo.ie,0020,[0001,0001],46dd4e2c81bb15ef9d194c99b86983844e2a1387e4fb7e7d3b8d368c8e1b4d2a,00,00]

=head2 ECH Split-Mode

TODO(ECH) figure out what to do about SSL_CTX_ech_raw_decrypt().

=head2 Constants

Some externally visible limits:

=over 4

=item B<OSSL_ECH_MAX_PAYLOAD_LEN> 1500, max ECH ciphertext to en/decode

=item B<OSSL_ECH_MIN_ECHCONFIG_LEN> 32, min for all encodings

=item B<OSSL_ECH_MAX_ECHCONFIG_LEN> 1500, max for all encodings

=item B<OSSL_ECH_MAX_ECHCONFIGEXT_LEN> 512, ECHConfig extension max

=item B<OSSL_ECH_MAX_MAXNAMELEN> 255, ECHConfig max for max name length

=item B<OSSL_ECH_MAX_PUBLICNAME> 255, max ECHConfig public name length

=item B<OSSL_ECH_MAX_ALPN_LEN> 255, max alpn overall length

=item B< OSSL_ECH_OUTERS_MAX> 20, max extensions we compress via outer-exts

=item B< OSSL_ECH_ALLEXTS_MAX> 32, max total number of extension we allow


=back

ECH version - we only support version 0xfe0d as of now.

=over 4

=item B<OSSL_ECH_RFCXXXX_VERSION> 0xfe0d, official ECHConfig version

=item B<OSSL_ECH_CURRENT_VERSION> OSSL_ECH_RFCXXXX_VERSION

=back

Return codes from SSL_ech_get_status

=over 4

=item B<SSL_ECH_STATUS_BACKEND>    4, ECH backend: saw an ech_is_inner

=item B<SSL_ECH_STATUS_GREASE_ECH> 3, GREASEd and got an ECH in return

=item B<SSL_ECH_STATUS_GREASE>     2, ECH GREASE happened

=item B<SSL_ECH_STATUS_SUCCESS>    1, Success

=item B<SSL_ECH_STATUS_FAILED>     0, Some internal or protocol error

=item B<SSL_ECH_STATUS_BAD_CALL>   -100, Some in/out arguments were NULL

=item B<SSL_ECH_STATUS_NOT_TRIED>  -101, ECH wasn't attempted

=item B<SSL_ECH_STATUS_BAD_NAME>   -102, ECH ok but server cert bad

=item B<SSL_ECH_STATUS_NOT_CONFIGURED> -103, ECH wasn't configured

=item B<SSL_ECH_STATUS_FAILED_ECH> -105, We tried, failed and got an ECH, from a verified name

=item B<SSL_ECH_STATUS_FAILED_ECH_BAD_NAME> -106, We tried, failed and got an ECH, from a bad name

=back

Values for I<for_retry>

=over 4

=item B<SSL_ECH_USE_FOR_RETRY>  1. use corresponding ECHConfig values

=item B<SSL_ECH_NOT_FOR_RETRY>  0. don't use corresponding ECHConfig values

=back

Indexing an OSSL_ECHSTORE

=over 4

=item B<OSSL_ECHSTORE_LAST>, -1 select the last entry in the store

=item B<OSSL_ECHSTORE_ALL>, -2 select all entries in the store, e.g. to print public values

=back


=head1 RETURN VALUES

SSL_set1_echstore(), SSL_set1_ech_config_list(), OSSL_ECHSTORE_new_config(),
OSSL_ECHSTORE_write_pem(), OSSL_ECHSTORE_read_echconfiglist(),
OSSL_ECHSTORE_get1_info(), OSSL_ECHSTORE_downselect(),
OSSL_ECHSTORE_set1_key_and_read_pem(), OSSL_ECHSTORE_read_pem(),
OSSL_ECHSTORE_num_keys(), OSSL_ECHSTORE_num_entries(),
OSSL_ECHSTORE_flush_keys(), SSL_CTX_set1_echstore(), SSL_CTX_get1_echstore(),
SSL_get1_echstore(), SSL_ech_set_server_names(),
SSL_ech_set_outer_server_name(), SSL_ech_set_outer_alpn_protos(),
SSL_ech_get1_status(), SSL_ech_set_grease_suite(), SSL_ech_set_grease_type(),
SSL_ech_get_retry_config(), SSL_CTX_ech_set1_outer_alpn_protos() and
SSL_CTX_ech_raw_decrypt() all return zero on error and one on success.

SSL_ech_set_callback(), SSL_CTX_ech_set_callback(), OSSL_ECHSTORE_free() have
no return.

OSSL_ECHSTORE_new() returns a pointer to an B<OSSL_ECHSTORE>.

Note that SSL_CTX_ech_set1_outer_alpn_protos() and
SSL_ech_set1_outer_alpn_protos() return zero on error and 1 on success.  This
is in contrast to SSL_CTX_set1_alpn_protos() and SSL_set1_alpn_protos() which
(unusually for OpenSSL) return 0 on success and 1 on error.

=head1 SEE ALSO

=over 4

=item Encrypted ClientHello specification: L<https://datatracker.ietf.org/doc/draft-ietf-tls-esni/>

=item ECH PEM file format specification: L<https://datatracker.ietf.org/doc/draft-farrell-tls-pemesni/>

=item RFC8701: L<https://datatracker.ietf.org/doc/html/rfc8701>

=back

ECH command line options are described in the manual pages for
L<openssl-s_client(1)>, L<openssl-s_server(1)> and L<openssl-ech(1)>.

=head1 HISTORY

The functionality described here was added in OpenSSL 4.0.

=head1 COPYRIGHT

Copyright 2025 The OpenSSL Project Authors. All Rights Reserved.

Licensed under the Apache License 2.0 (the "License").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file LICENSE in the source distribution or at
L<https://www.openssl.org/source/license.html>.

=cut
