
=pod

=head1 NAME

SSL - OpenSSL SSL/TLS library

=head1 SYNOPSIS

=head1 DESCRIPTION

The OpenSSL B<ssl> library implements the Secure Sockets Layer (SSL v2/v3) and
Transport Layer Security (TLS v1) protocols. It provides a rich API which is
documented here.

=head1 HEADERS

Currently the OpenSSL B<ssl> library provides the following C header files
containing the prototypes for the data structures and and functions:

=over 4

=item B<ssl.h>

That's the common header file for the SSL/TLS API.  Include it into your
program to make the API of the B<ssl> library available. It internally
includes both more private SSL headers and headers from the B<crypto> library.

=back

=head1 STRUCTURES

Currently the OpenSSL B<ssl> library functions deal with the following data
structures:

=over 4

=item B<SSL_CTX> (SSL Context)

=item B<SSL> (SSL Connection)

That's the SSL/TLS structure which is created by
a server or client per established connection. 

=item B<SSL_METHOD> (SSL Method)

=item B<SSL_CIPHER> (SSL Cipher)

=item B<SSL_SESSION> (SSL Session)

=back

=head1 FUNCTIONS

Currently the OpenSSL B<ssl> library exports 143 API functions.
They are documented in the following:

=over 4

=item [MACRO] B<SSL_ADH>(SSL_kEDH|SSL_aNULL);

=item [MACRO] B<SSL_CB_ACCEPT_EXIT>(SSL_ST_ACCEPT|SSL_CB_EXIT);

=item [MACRO] B<SSL_CB_ACCEPT_LOOP>(SSL_ST_ACCEPT|SSL_CB_LOOP);

=item [MACRO] B<SSL_CB_CONNECT_EXIT>(SSL_ST_CONNECT|SSL_CB_EXIT);

=item [MACRO] B<SSL_CB_CONNECT_LOOP>(SSL_ST_CONNECT|SSL_CB_LOOP);

=item [MACRO] B<SSL_CB_READ_ALERT>(SSL_CB_ALERT|SSL_CB_READ);

=item [MACRO] B<SSL_CB_WRITE_ALERT>(SSL_CB_ALERT|SSL_CB_WRITE);

=item char *B<SSL_CIPHER_description>(SSL_CIPHER *cipher, char *buf, int len);

=item int B<SSL_CIPHER_get_bits>(SSL_CIPHER *c, int *alg_bits);

=item char *B<SSL_CIPHER_get_name>(SSL_CIPHER *c);

=item char *B<SSL_CIPHER_get_version>(SSL_CIPHER *c);

=item int B<SSL_CTX_add_client_CA>(SSL_CTX *ctx, X509 *x);

=item [MACRO] B<SSL_CTX_add_extra_chain_cert>(ctx,x509);

=item int B<SSL_CTX_add_session>(SSL_CTX *ctx, SSL_SESSION *c);

=item int B<SSL_CTX_check_private_key>(SSL_CTX *ctx);

=item long B<SSL_CTX_ctrl>(SSL_CTX *ctx, int cmd, long larg, char *parg);

=item void B<SSL_CTX_flush_sessions>(SSL_CTX *s, long t);

=item void B<SSL_CTX_free>(SSL_CTX *a);

=item [MACRO] B<SSL_CTX_get_app_data>(ctx);

=item [MACRO] B<SSL_CTX_get_cert_store>(ctx);

=item STACK *B<SSL_CTX_get_client_CA_list>(SSL_CTX *ctx);

=item [MACRO] B<SSL_CTX_get_client_cert_cb>(ctx);

=item char *B<SSL_CTX_get_ex_data>(SSL_CTX *s, int idx);

=item int B<SSL_CTX_get_ex_new_index>(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))

=item [MACRO] B<SSL_CTX_get_info_callback>(ctx);

=item int B<SSL_CTX_get_quiet_shutdown>(SSL_CTX *ctx);

=item [MACRO] B<SSL_CTX_get_session_cache_mode>(ctx);

=item [MACRO] B<SSL_CTX_get_timeout>(ctx);

=item int (*B<SSL_CTX_get_verify_callback>(SSL_CTX *ctx);)(void)

=item int B<SSL_CTX_get_verify_mode>(SSL_CTX *ctx);

=item int B<SSL_CTX_load_verify_locations>(SSL_CTX *ctx, char *CAfile, char *CApath);

=item [MACRO] B<SSL_CTX_need_tmp_RSA>(ctx);

=item SSL_CTX *B<SSL_CTX_new>(SSL_METHOD *meth);

=item int B<SSL_CTX_remove_session>(SSL_CTX *ctx, SSL_SESSION *c);

=item [MACRO] B<SSL_CTX_sess_accept>(ctx);

=item [MACRO] B<SSL_CTX_sess_accept_good>(ctx);

=item [MACRO] B<SSL_CTX_sess_accept_renegotiate>(ctx);

=item [MACRO] B<SSL_CTX_sess_cache_full>(ctx);

=item [MACRO] B<SSL_CTX_sess_cb_hits>(ctx);

=item [MACRO] B<SSL_CTX_sess_connect>(ctx);

=item [MACRO] B<SSL_CTX_sess_connect_good>(ctx);

=item [MACRO] B<SSL_CTX_sess_connect_renegotiate>(ctx);

=item [MACRO] B<SSL_CTX_sess_get_cache_size>(ctx);

=item [MACRO] B<SSL_CTX_sess_get_get_cb>(ctx);

=item [MACRO] B<SSL_CTX_sess_get_new_cb>(ctx);

=item [MACRO] B<SSL_CTX_sess_get_remove_cb>(ctx);

=item [MACRO] B<SSL_CTX_sess_hits>(ctx);

=item [MACRO] B<SSL_CTX_sess_misses>(ctx);

=item [MACRO] B<SSL_CTX_sess_number>(ctx);

=item [MACRO] B<SSL_CTX_sess_set_cache_size>(ctx,t);

=item [MACRO] B<SSL_CTX_sess_set_get_cb>(ctx,cb);

=item [MACRO] B<SSL_CTX_sess_set_new_cb>(ctx,cb);

=item [MACRO] B<SSL_CTX_sess_set_remove_cb>(ctx,cb);

=item [MACRO] B<SSL_CTX_sess_timeouts>(ctx);

=item [MACRO] B<SSL_CTX_sessions>(ctx);

=item [MACRO] B<SSL_CTX_set_app_data>(ctx,arg);

=item [MACRO] B<SSL_CTX_set_cert_store>(ctx,cs);

=item [MACRO] B<SSL_CTX_set_cert_verify_callback>(a,b,c);

=item void B<SSL_CTX_set_cert_verify_cb>(SSL_CTX *ctx, int (*cb);(void), char *arg)

=item int B<SSL_CTX_set_cipher_list>(SSL_CTX *ctx, char *str);

=item void B<SSL_CTX_set_client_CA_list>(SSL_CTX *ctx, STACK *list);

=item [MACRO] B<SSL_CTX_set_client_cert_cb>(ctx,cb);

=item void B<SSL_CTX_set_default_passwd_cb>(SSL_CTX *ctx, int (*cb);(void))

=item [MACRO] B<SSL_CTX_set_default_read_ahead>(ctx,m);

=item [MACRO] B<SSL_CTX_set_default_verify>(a,b,c);

=item int B<SSL_CTX_set_default_verify_paths>(SSL_CTX *ctx);

=item int B<SSL_CTX_set_ex_data>(SSL_CTX *s, int idx, char *arg);

=item [MACRO] B<SSL_CTX_set_info_callback>(ctx,cb);

=item [MACRO] B<SSL_CTX_set_options>(ctx,op);

=item void B<SSL_CTX_set_quiet_shutdown>(SSL_CTX *ctx, int mode);

=item [MACRO] B<SSL_CTX_set_session_cache_mode>(ctx,m);

=item int B<SSL_CTX_set_ssl_version>(SSL_CTX *ctx, SSL_METHOD *meth);

=item [MACRO] B<SSL_CTX_set_timeout>(ctx,t);

=item [MACRO] B<SSL_CTX_set_tmp_dh>(ctx,dh);

=item [MACRO] B<SSL_CTX_set_tmp_dh_callback>(ctx,dh);

=item [MACRO] B<SSL_CTX_set_tmp_rsa>(ctx,rsa);

=item [MACRO] B<SSL_CTX_set_tmp_rsa_callback>(ctx,cb);

=item void B<SSL_CTX_set_verify>(SSL_CTX *ctx, int mode, int (*cb);(void))

=item int B<SSL_CTX_use_PrivateKey>(SSL_CTX *ctx, EVP_PKEY *pkey);

=item int B<SSL_CTX_use_PrivateKey_ASN1>(int type, SSL_CTX *ctx, unsigned char *d, long len);

=item int B<SSL_CTX_use_PrivateKey_file>(SSL_CTX *ctx, char *file, int type);

=item int B<SSL_CTX_use_RSAPrivateKey>(SSL_CTX *ctx, RSA *rsa);

=item int B<SSL_CTX_use_RSAPrivateKey_ASN1>(SSL_CTX *ctx, unsigned char *d, long len);

=item int B<SSL_CTX_use_RSAPrivateKey_file>(SSL_CTX *ctx, char *file, int type);

=item int B<SSL_CTX_use_certificate>(SSL_CTX *ctx, X509 *x);

=item int B<SSL_CTX_use_certificate_ASN1>(SSL_CTX *ctx, int len, unsigned char *d);

=item int B<SSL_CTX_use_certificate_file>(SSL_CTX *ctx, char *file, int type);

=item [MACRO] B<SSL_DH>(SSL_kDHr|SSL_kDHd|SSL_kEDH);

=item [MACRO] B<SSL_EDH>(SSL_kEDH|(SSL_AUTH_MASK^SSL_aNULL);

=item [MACRO] B<SSL_FZA>(SSL_aFZA|SSL_kFZA|SSL_eFZA);

=item [MACRO] B<SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES>(512/8);

=item [MACRO] B<SSL_NULL>(SSL_eNULL);

=item [MACRO] B<SSL_RSA>(SSL_kRSA|SSL_aRSA);

=item [MACRO] B<SSL_SESSION_CACHE_MAX_SIZE_DEFAULT>(1024*20);

=item int B<SSL_SESSION_cmp>(SSL_SESSION *a, SSL_SESSION *b);

=item void B<SSL_SESSION_free>(SSL_SESSION *ss);

=item [MACRO] B<SSL_SESSION_get_app_data>(s);

=item char *B<SSL_SESSION_get_ex_data>(SSL_SESSION *s, int idx);

=item int B<SSL_SESSION_get_ex_new_index>(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))

=item long B<SSL_SESSION_get_time>(SSL_SESSION *s);

=item long B<SSL_SESSION_get_timeout>(SSL_SESSION *s);

=item unsigned long B<SSL_SESSION_hash>(SSL_SESSION *a);

=item SSL_SESSION *B<SSL_SESSION_new>(void);

=item int B<SSL_SESSION_print>(BIO *bp, SSL_SESSION *x);

=item int B<SSL_SESSION_print_fp>(FILE *fp, SSL_SESSION *x);

=item [MACRO] B<SSL_SESSION_set_app_data>(s,a);

=item int B<SSL_SESSION_set_ex_data>(SSL_SESSION *s, int idx, char *arg);

=item long B<SSL_SESSION_set_time>(SSL_SESSION *s, long t);

=item long B<SSL_SESSION_set_timeout>(SSL_SESSION *s, long t);

=item [MACRO] B<SSL_SESS_CACHE_BOTH>(SSL_SESS_CACHE_CLIENT|SSL_SESS_CACHE_SERVER);

=item [MACRO] B<SSL_SHA>(SSL_SHA1);

=item [MACRO] B<SSL_ST_INIT>(SSL_ST_CONNECT|SSL_ST_ACCEPT);

=item [MACRO] B<SSL_ST_RENEGOTIATE>(0x04|SSL_ST_INIT);

=item int B<SSL_accept>(SSL *s);

=item int B<SSL_add_client_CA>(SSL *ssl, X509 *x);

=item [MACRO] B<SSL_add_session>(a,b);

=item char *B<SSL_alert_desc_string>(int value);

=item char *B<SSL_alert_desc_string_long>(int value);

=item char *B<SSL_alert_type_string>(int value);

=item char *B<SSL_alert_type_string_long>(int value);

=item int B<SSL_check_private_key>(SSL *ssl);

=item void B<SSL_clear>(SSL *s);

=item [MACRO] B<SSL_clear_num_renegotiations>(ssl);

=item int B<SSL_connect>(SSL *s);

=item void B<SSL_copy_session_id>(SSL *t, SSL *f);

=item long B<SSL_ctrl>(SSL *s, int cmd, long larg, char *parg);

=item int B<SSL_do_handshake>(SSL *s);

=item SSL *B<SSL_dup>(SSL *s);

=item STACK *B<SSL_dup_CA_list>(STACK *sk);

=item [MACRO] B<SSL_flush_sessions>(a,b);

=item void B<SSL_free>(SSL *s);

=item SSL_CTX *B<SSL_get_SSL_CTX>(SSL *ssl);

=item [MACRO] B<SSL_get_app_data>(s);

=item X509 *B<SSL_get_certificate>(SSL *s);

=item [MACRO] B<SSL_get_cipher>(s);

=item [MACRO] B<SSL_get_cipher_bits>(s,np);

=item char *B<SSL_get_cipher_list>(SSL *s, int n);

=item [MACRO] B<SSL_get_cipher_name>(s);

=item [MACRO] B<SSL_get_cipher_version>(s);

=item STACK *B<SSL_get_ciphers>(SSL *s);

=item STACK *B<SSL_get_client_CA_list>(SSL *s);

=item SSL_CIPHER *B<SSL_get_current_cipher>(SSL *s);

=item long B<SSL_get_default_timeout>(SSL *s);

=item int B<SSL_get_error>(SSL *s, int i);

=item char *B<SSL_get_ex_data>(SSL *s, int idx);

=item int B<SSL_get_ex_data_X509_STORE_CTX_idx>(void);

=item int B<SSL_get_ex_new_index>(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))

=item int B<SSL_get_fd>(SSL *s);

=item void (*B<SSL_get_info_callback>(SSL *ssl);)(void)

=item STACK *B<SSL_get_peer_cert_chain>(SSL *s);

=item X509 *B<SSL_get_peer_certificate>(SSL *s);

=item EVP_PKEY *B<SSL_get_privatekey>(SSL *s);

=item int B<SSL_get_quiet_shutdown>(SSL *s);

=item BIO *B<SSL_get_rbio>(SSL *s);

=item int B<SSL_get_read_ahead>(SSL *s);

=item SSL_SESSION *B<SSL_get_session>(SSL *ssl);

=item char *B<SSL_get_shared_ciphers>(SSL *s, char *buf, int len);

=item int B<SSL_get_shutdown>(SSL *s);

=item SSL_METHOD *B<SSL_get_ssl_method>(SSL *s);

=item [MACRO] B<SSL_get_state>(a);

=item [MACRO] B<SSL_get_time>(a);

=item [MACRO] B<SSL_get_timeout>(a);

=item int (*B<SSL_get_verify_callback>(SSL *s);)(void)

=item int B<SSL_get_verify_mode>(SSL *s);

=item long B<SSL_get_verify_result>(SSL *ssl);

=item char *B<SSL_get_version>(SSL *s);

=item BIO *B<SSL_get_wbio>(SSL *s);

=item [MACRO] B<SSL_in_accept_init>(a);

=item [MACRO] B<SSL_in_before>(a);

=item [MACRO] B<SSL_in_connect_init>(a);

=item [MACRO] B<SSL_in_init>(a);

=item [MACRO] B<SSL_is_init_finished>(a);

=item STACK *B<SSL_load_client_CA_file>(char *file);

=item void B<SSL_load_error_strings>(void);

=item SSL *B<SSL_new>(SSL_CTX *ctx);

=item [MACRO] B<SSL_num_renegotiations>(ssl);

=item int B<SSL_peek>(SSL *s, char *buf, int num);

=item int B<SSL_pending>(SSL *s);

=item int B<SSL_read>(SSL *s, char *buf, int num);

=item [MACRO] B<SSL_remove_session>(a,b);

=item int B<SSL_renegotiate>(SSL *s);

=item char *B<SSL_rstate_string>(SSL *s);

=item char *B<SSL_rstate_string_long>(SSL *s);

=item [MACRO] B<SSL_session_reused>(ssl);

=item void B<SSL_set_accept_state>(SSL *s);

=item [MACRO] B<SSL_set_app_data>(s,arg);

=item void B<SSL_set_bio>(SSL *s, BIO *rbio, BIO *wbio);

=item int B<SSL_set_cipher_list>(SSL *s, char *str);

=item void B<SSL_set_client_CA_list>(SSL *s, STACK *list);

=item void B<SSL_set_connect_state>(SSL *s);

=item int B<SSL_set_ex_data>(SSL *s, int idx, char *arg);

=item int B<SSL_set_fd>(SSL *s, int fd);

=item void B<SSL_set_info_callback>(SSL *ssl, void (*cb);(void))

=item [MACRO] B<SSL_set_options>(ssl,op);

=item [MACRO] B<SSL_set_pref_cipher>(c,n);

=item void B<SSL_set_quiet_shutdown>(SSL *s, int mode);

=item void B<SSL_set_read_ahead>(SSL *s, int yes);

=item int B<SSL_set_rfd>(SSL *s, int fd);

=item int B<SSL_set_session>(SSL *s, SSL_SESSION *session);

=item void B<SSL_set_shutdown>(SSL *s, int mode);

=item int B<SSL_set_ssl_method>(SSL *s, SSL_METHOD *meth);

=item [MACRO] B<SSL_set_time>(a,b);

=item [MACRO] B<SSL_set_timeout>(a,b);

=item void B<SSL_set_verify>(SSL *s, int mode, int (*callback);(void))

=item void B<SSL_set_verify_result>(SSL *ssl, long arg);

=item int B<SSL_set_wfd>(SSL *s, int fd);

=item int B<SSL_shutdown>(SSL *s);

=item int B<SSL_state>(SSL *ssl);

=item char *B<SSL_state_string>(SSL *s);

=item char *B<SSL_state_string_long>(SSL *s);

=item [MACRO] B<SSL_total_renegotiations>(ssl);

=item int B<SSL_use_PrivateKey>(SSL *ssl, EVP_PKEY *pkey);

=item int B<SSL_use_PrivateKey_ASN1>(int type, SSL *ssl, unsigned char *d, long len);

=item int B<SSL_use_PrivateKey_file>(SSL *ssl, char *file, int type);

=item int B<SSL_use_RSAPrivateKey>(SSL *ssl, RSA *rsa);

=item int B<SSL_use_RSAPrivateKey_ASN1>(SSL *ssl, unsigned char *d, long len);

=item int B<SSL_use_RSAPrivateKey_file>(SSL *ssl, char *file, int type);

=item int B<SSL_use_certificate>(SSL *ssl, X509 *x);

=item int B<SSL_use_certificate_ASN1>(SSL *ssl, int len, unsigned char *d);

=item int B<SSL_use_certificate_file>(SSL *ssl, char *file, int type);

=item int B<SSL_version>(SSL *s);

=item [MACRO] B<SSL_want>(s);

=item [MACRO] B<SSL_want_nothing>(s);

=item [MACRO] B<SSL_want_read>(s);

=item [MACRO] B<SSL_want_write>(s);

=item [MACRO] B<SSL_want_x509_lookup>(s);

=item int B<SSL_write>(SSL *s, char *buf, int num);

=item SSL_METHOD *B<SSLv2_client_method>(void);

=item SSL_METHOD *B<SSLv2_method>(void);

=item SSL_METHOD *B<SSLv2_server_method>(void);

=item SSL_METHOD *B<SSLv3_client_method>(void);

=item SSL_METHOD *B<SSLv3_method>(void);

=item SSL_METHOD *B<SSLv3_server_method>(void);

=item SSL_METHOD *B<TLSv1_client_method>(void);

=item SSL_METHOD *B<TLSv1_method>(void);

=item SSL_METHOD *B<TLSv1_server_method>(void);

=back

=head1 SEE ALSO

openssl(1), crypto(3)

=head1 HISTORY

The ssl(3) document appeared in OpenSSL 0.9.2

=cut

